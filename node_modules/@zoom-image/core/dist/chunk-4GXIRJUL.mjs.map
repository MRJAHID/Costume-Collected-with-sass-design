{"version":3,"sources":["../src/createZoomImageWheel.ts"],"names":["ZOOM_DELTA","createZoomImageWheel","container","options","store","f","sourceImgElement","getSourceImage","finalOptions","calculatePositionX","newPositionX","currentZoom","width","calculatePositionY","newPositionY","height","prevDistance","enabledScroll","zoomType","pointerMap","isOnMove","lastPositionX","lastPositionY","startX","startY","updateZoom","currentState","setState","newState","newCurrentZoom","clamp","zoomPointX","zoomPointY","zoomTargetX","zoomTargetY","processZoomWheel","delta","x","y","containerRect","_onWheel","event","_handlePointerMove","clientX","clientY","pointerId","cachedPointerid","pointersIterator","first","second","curDistance","getPointersCenter","offsetX","offsetY","_handlePointerDown","disableScroll","_handlePointerUp","enableScroll","_handlePointerLeave","checkZoomEnabled","onWheel","makeMaybeCallFunction","handlePointerDown","handlePointerLeave","handlePointerMove","handlePointerUp","controller","signal"],"mappings":"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","sourcesContent":["import { createStore } from \"@namnode/store\"\nimport { clamp, disableScroll, enableScroll, getPointersCenter, getSourceImage, makeMaybeCallFunction } from \"./utils\"\nimport type { PointerPosition } from \"./utils\"\n\nexport type ZoomImageWheelOptions = {\n  maxZoom?: number\n  wheelZoomRatio?: number\n}\n\n/* The delta values are not consistent across browsers.\n * We need to normalize them to a consistent value.\n * https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent/deltaY\n */\nconst ZOOM_DELTA = 0.5\n\nexport type ZoomImageWheelState = {\n  currentZoom: number\n  enable: boolean\n  currentPositionX: number\n  currentPositionY: number\n}\n\nexport type ZoomImageWheelStateUpdate = Partial<{ enable: boolean; currentZoom: number }>\n\nexport function createZoomImageWheel(container: HTMLElement, options: ZoomImageWheelOptions = {}) {\n  const store = createStore<ZoomImageWheelState>({\n    currentZoom: 1,\n    enable: true,\n    currentPositionX: 0,\n    currentPositionY: 0,\n  })\n\n  const sourceImgElement = getSourceImage(container)\n  const finalOptions: Required<ZoomImageWheelOptions> = {\n    maxZoom: options.maxZoom || 4,\n    wheelZoomRatio: options.wheelZoomRatio || 0.1,\n  }\n\n  const calculatePositionX = (newPositionX: number, currentZoom: number) => {\n    const width = container.clientWidth\n    if (newPositionX > 0) return 0\n    if (newPositionX + width * currentZoom < width) return -width * (currentZoom - 1)\n    return newPositionX\n  }\n\n  const calculatePositionY = (newPositionY: number, currentZoom: number) => {\n    const height = container.clientHeight\n\n    if (newPositionY > 0) return 0\n    if (newPositionY + height * currentZoom < height) return -height * (currentZoom - 1)\n    return newPositionY\n  }\n\n  let prevDistance = -1\n  let enabledScroll = true\n  let zoomType: \"wheel\" | \"pinch\" | \"\" = \"\"\n  const pointerMap = new Map<number, { x: number; y: number }>()\n\n  let isOnMove = false\n  let lastPositionX = 0\n  let lastPositionY = 0\n  let startX = 0\n  let startY = 0\n\n  container.style.overflow = \"hidden\"\n  sourceImgElement.style.transformOrigin = \"0 0\"\n\n  function updateZoom() {\n    const currentState = store.getState()\n    sourceImgElement.style.transform = `translate(${currentState.currentPositionX}px, ${currentState.currentPositionY}px) scale(${currentState.currentZoom})`\n  }\n\n  function setState(newState: ZoomImageWheelStateUpdate) {\n    store.batch(() => {\n      const currentState = store.getState()\n      if (typeof newState.enable === \"boolean\" && newState.enable !== currentState.enable) {\n        store.setState({\n          enable: newState.enable,\n        })\n\n        if (!newState.enable) {\n          return\n        }\n      }\n\n      if (typeof newState.currentZoom === \"number\" && newState.currentZoom !== currentState.currentZoom) {\n        const newCurrentZoom = clamp(newState.currentZoom, 1, finalOptions.maxZoom)\n\n        if (newCurrentZoom === currentState.currentZoom) {\n          return\n        }\n\n        const zoomPointX = container.clientWidth / 2\n        const zoomPointY = container.clientHeight / 2\n\n        const zoomTargetX = (zoomPointX - currentState.currentPositionX) / currentState.currentZoom\n        const zoomTargetY = (zoomPointY - currentState.currentPositionY) / currentState.currentZoom\n\n        store.setState({\n          currentZoom: newCurrentZoom,\n          currentPositionX: calculatePositionX(-zoomTargetX * newCurrentZoom + zoomPointX, newCurrentZoom),\n          currentPositionY: calculatePositionY(-zoomTargetY * newCurrentZoom + zoomPointY, newCurrentZoom),\n        })\n      }\n    })\n\n    updateZoom()\n  }\n\n  function processZoomWheel({ delta, x, y }: { delta: number; x: number; y: number }) {\n    const containerRect = container.getBoundingClientRect()\n    const zoomPointX = x - containerRect.left\n    const zoomPointY = y - containerRect.top\n    const currentState = store.getState()\n\n    const zoomTargetX = (zoomPointX - currentState.currentPositionX) / currentState.currentZoom\n    const zoomTargetY = (zoomPointY - currentState.currentPositionY) / currentState.currentZoom\n\n    const newCurrentZoom = clamp(\n      currentState.currentZoom + delta * finalOptions.wheelZoomRatio * currentState.currentZoom,\n      1,\n      finalOptions.maxZoom,\n    )\n\n    store.setState({\n      currentZoom: newCurrentZoom,\n      currentPositionX: calculatePositionX(-zoomTargetX * newCurrentZoom + zoomPointX, newCurrentZoom),\n      currentPositionY: calculatePositionY(-zoomTargetY * newCurrentZoom + zoomPointY, newCurrentZoom),\n    })\n  }\n\n  function _onWheel(event: WheelEvent) {\n    event.preventDefault()\n    const delta = -clamp(event.deltaY, -ZOOM_DELTA, ZOOM_DELTA)\n    processZoomWheel({ delta, x: event.clientX, y: event.clientY })\n    updateZoom()\n  }\n\n  function _handlePointerMove(event: PointerEvent) {\n    event.preventDefault()\n    const { clientX, clientY, pointerId } = event\n    for (const [cachedPointerid] of pointerMap.entries()) {\n      if (cachedPointerid === pointerId) {\n        pointerMap.set(cachedPointerid, { x: clientX, y: clientY })\n      }\n    }\n\n    if (!isOnMove) {\n      return\n    }\n\n    if (pointerMap.size === 2 && zoomType === \"pinch\") {\n      const pointersIterator = pointerMap.values()\n      const first = pointersIterator.next().value as PointerPosition\n      const second = pointersIterator.next().value as PointerPosition\n      const curDistance = Math.sqrt(Math.pow(first.x - second.x, 2) + Math.pow(first.y - second.y, 2))\n      const { x, y } = getPointersCenter(first, second)\n      if (prevDistance > 0) {\n        if (curDistance > prevDistance) {\n          // The distance between the two pointers has increased\n          processZoomWheel({ delta: ZOOM_DELTA, x, y })\n        }\n        if (curDistance < prevDistance) {\n          // The distance between the two pointers has decreased\n          processZoomWheel({ delta: -ZOOM_DELTA, x, y })\n        }\n      }\n      // Store the distance for the next move event\n      prevDistance = curDistance\n      updateZoom()\n      return\n    }\n\n    if (pointerMap.size === 1 && zoomType !== \"pinch\") {\n      const offsetX = clientX - startX\n      const offsetY = clientY - startY\n      const { currentZoom } = store.getState()\n      store.setState({\n        currentPositionX: calculatePositionX(lastPositionX + offsetX, currentZoom),\n        currentPositionY: calculatePositionY(lastPositionY + offsetY, currentZoom),\n      })\n      updateZoom()\n    }\n  }\n\n  function _handlePointerDown(event: PointerEvent) {\n    event.preventDefault()\n\n    if (pointerMap.size === 2) {\n      return\n    }\n\n    if (enabledScroll) {\n      disableScroll()\n      enabledScroll = false\n    }\n\n    const { clientX, clientY, pointerId } = event\n    isOnMove = true\n    const currentState = store.getState()\n    lastPositionX = currentState.currentPositionX\n    lastPositionY = currentState.currentPositionY\n    startX = clientX\n    startY = clientY\n    pointerMap.set(pointerId, { x: clientX, y: clientY })\n\n    if (pointerMap.size === 2) {\n      zoomType = \"pinch\"\n    }\n  }\n\n  function _handlePointerUp(event: PointerEvent) {\n    pointerMap.delete(event.pointerId)\n\n    if (pointerMap.size === 0) {\n      isOnMove = false\n      prevDistance = -1\n    }\n\n    if (pointerMap.size === 0 && !enabledScroll) {\n      enableScroll()\n      enabledScroll = true\n    }\n\n    if (pointerMap.size === 0 && zoomType === \"pinch\") {\n      zoomType = \"\"\n    }\n\n    const currentState = store.getState()\n    lastPositionX = currentState.currentPositionX\n    lastPositionY = currentState.currentPositionY\n  }\n\n  function _handlePointerLeave() {\n    pointerMap.clear()\n    isOnMove = false\n    prevDistance = -1\n    if (!enabledScroll) {\n      enableScroll()\n      enabledScroll = true\n    }\n  }\n\n  function checkZoomEnabled() {\n    return store.getState().enable\n  }\n\n  const onWheel = makeMaybeCallFunction(checkZoomEnabled, _onWheel)\n  const handlePointerDown = makeMaybeCallFunction(checkZoomEnabled, _handlePointerDown)\n  const handlePointerLeave = makeMaybeCallFunction(checkZoomEnabled, _handlePointerLeave)\n  const handlePointerMove = makeMaybeCallFunction(checkZoomEnabled, _handlePointerMove)\n  const handlePointerUp = makeMaybeCallFunction(checkZoomEnabled, _handlePointerUp)\n\n  const controller = new AbortController()\n  const { signal } = controller\n  container.addEventListener(\"wheel\", onWheel, { signal })\n  container.addEventListener(\"pointerdown\", handlePointerDown, { signal })\n  container.addEventListener(\"pointerleave\", handlePointerLeave, { signal })\n  container.addEventListener(\"pointermove\", handlePointerMove, { signal })\n  container.addEventListener(\"pointerup\", handlePointerUp, { signal })\n\n  return {\n    cleanup() {\n      controller.abort()\n      store.cleanup()\n    },\n    subscribe: store.subscribe,\n    setState,\n    getState: store.getState,\n  }\n}\n"]}